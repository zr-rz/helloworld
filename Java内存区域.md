# Java内存区域

## 一、概述

在虚拟机自动管理内存机制下，不需要为new操作去写对应的delete/free操作。Java程序员将内存控制权利交给Java虚拟机。

## 二、 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。

![img](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)

**线程私有的：虚拟机栈、程序计数器、本地方法栈**

**线程共享的：堆、方法区、直接内存（非运行时数据区的一部分）**

#### 2.1 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

**为了线程切换之后能够恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

**程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器的值来依次读取指令，从而实现代码的流程控制。如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候就能知道上次线程执行到哪了。

**程序计数器随着线程创建而创建，随着线程结束而死亡。**

#### 2.2 虚拟机栈

**Java虚拟机栈也是线程私有的，生命周期和线程相同。**

**Java内存可以粗糙的分为堆内存和栈内存，其中的栈说的就是虚拟机栈，或者说是虚拟机栈中局部变量表部分。**

**局部变量表主要存放了编译期可知的各种数据类型**（boolean、char、int、long、short、float、double、byte）、**引用数据类型**（可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

#### 2.3 本地方法栈

和虚拟机栈非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。在HotSpot虚拟机中二者合二为一。

#### 2.4 堆

Java虚拟机管理的最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例和数组。**

Java堆是垃圾收集器管理的主要区域，也被称作GC堆（Garbage Collection Heap），从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆可以细分为：新生代和老年代；更细致一点有：Eden空间、From survivor、To Survivor空间等。**进一步细分的目的是更好的回收内存，或更快的分配内存。**

JDK1.7之前堆内存分为以下三个部分：新生代内存、老年代内存、永生代。

![JVM堆内存结构-JDK7](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png)

JDK8之后方法区（HotSpot的永久代）被移除了，取而代之的是元空间，元空间使用的是直接内存。

![JVM堆内存结构-JDK8](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png)

上图所示的Eden区、两个Survivor都属于新生代（为了区分，这两个Survivor区域按照顺序被命名为from和to），中间一层属于老年代。

大部分情况，对象都会在Eden区域创建，经过一次新生代垃圾回收，若对象仍然存活，则会进入s0或s1，并且对象的年龄增加1（Eden区到Survivor区后对象的初始年龄变为1），当它的年龄到15岁的时候，就会晋升到老年代中。

#### 2.5 方法区

方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也被称为永久代。

##### 2.5.1 为什么要将永久代换位元空间

整个永久代有一个JVM本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，元空间溢出的几率比原来的小。

#### 2.6 运行时常量池

运行时常量池是方法区的一部分。**JDK1.7字符串常量池被从方法区拿到了堆中，运行时常量池剩下的东西还在方法取，也就是永久代。JDK1.8hotspot移除了永久代用元空间代替，字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间。**

#### 2.7 直接内存

## 三、HotSpot虚拟机

HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

#### 3.1 对象的创建

对象创建的过程：1.类加载检查 2.分配内存 3.初始化零值 4.设置对象头 5.执行init方法

![Java创建对象的过程](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png)

**Step1：类加载检查**

虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能够在常量池中定位到这个类的符号引用，并检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

**Step2：分配内存**

在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成之后就被确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。分配方式有**“指针碰撞”**和**“空闲列表”**两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整取决于采用的垃圾收集器是否带有压缩整理功能决定。

**Step3：初始化零值**

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在Java代码中可以不赋值直接使用，程序能访问到这些字段的数据类型所对应的零值。

**Step4：设置对象头**

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息都存在对象头中。

**Step5：执行init方法**

上面工作完成之后从虚拟机角度来看一个新的对象已经产生；但是从Java程序角度来看，对象创建才刚开始，<init>方法还没执行，所有字段都还为零。所以一般来说，执行new指令之后会接着执行<init>方法，将对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全生产出来。

#### 3.2 对象的内存布局

对象在内存中的布局可以分为3部分：**对象头、实例数据、对齐填充**

HotSpot虚拟机的对象头包括两部分信息：**第一部分用于存储对象自身的运行时数据**（哈希码、GC分代年龄、锁状态标志等），**另一部分用于存储类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

对齐填充部分不是必然存在的，仅仅起到占位作用。

#### 3.3 对象的访问定位

Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针。

**句柄**：使用句柄的话，堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体信息。

![对象的访问定位-使用句柄](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png)

**直接指针**：使用直接指针访问，堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象的地址。









